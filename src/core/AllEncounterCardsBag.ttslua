local cardIdIndex  = {}
local indexingDone = false

function onLoad()
  self.addContextMenuItem("Rebuild Index", rebuildIndex)
  math.randomseed(os.time())
  Wait.frames(rebuildIndex, 30)
end

function rebuildIndex()
  if indexingDone then
    startIndexBuild()
  end
end

function startIndexBuild()
  indexingDone = false
  cardIdIndex  = {}
  startLuaCoroutine(self, "buildIndex")
end

function buildIndex()
  cardCount = 0
  indexingDone = false
  processContainedObjects(self.getData().ContainedObjects)
  indexingDone = true
  return 1
end

-- Processes the contained objects for cards to add to the index
function processContainedObjects(containedObjects, customDeck)
  for _, objData in ipairs(containedObjects or {}) do
    if objData.ContainedObjects then
      -- recursively process nested containers
      processContainedObjects(objData.ContainedObjects, objData.CustomDeck)
    elseif objData.Name == "Card" or objData.Name == "CardCustom" then
      if customDeck then
        -- we might need to fix the "CustomDeck" entry for cards inside decks since TTS doesn't update it while they are in bags
        local wantedCustomDeckIdStr = tostring(objData.CardID):sub(1, -3)
        local presentCustomDeckIdNum = next(objData.CustomDeck)

        -- type conversion (TTS seems to store these as strings, but reads them as numbers)
        local wantedCustomDeckIdNum = tonumber(wantedCustomDeckIdStr)
        if wantedCustomDeckIdNum ~= presentCustomDeckIdNum then
          if customDeck[wantedCustomDeckIdNum] then
            objData.CustomDeck = {}
            objData.CustomDeck[wantedCustomDeckIdStr] = customDeck[wantedCustomDeckIdNum]
            log("Corrected CustomDeckData for " .. objData.Nickname)
          else
            log("Could not correct CustomDeckData for " .. objData.Nickname)
            return
          end
        end
      end

      addCardToIndex(objData)
      cardCount = cardCount + 1
      if cardCount > 19 then
        cardCount = 0
        coroutine.yield(0)
      end
    end
  end
end

function addCardToIndex(cardData)
  local length = string.len(cardData["Nickname"])
  if length == 5 or length == 6 then
    cardIdIndex[cardData["Nickname"]] = { data = cardData }
  end
end

function isIndexReady()
  if not indexingDone then
    broadcastToAll("Still loading player cards, please try again in a few seconds", { 0.9, 0.2, 0.2 })
  end
  return indexingDone
end

function getCardById(params)
  if not isIndexReady() then return {} end
  return cardIdIndex[params.id]
end

function onObjectEnterContainer(container)
  if container ~= self then return end
  delayedIndexUpdate()
end

function onObjectLeaveContainer(container)
  if container ~= self then return end
  delayedIndexUpdate()
end

-- updates the index if there weren't changes for a specified amount of time
function delayedIndexUpdate()
  if waitId then
    Wait.stop(waitId)
  end
  waitId = Wait.time(rebuildIndex, 2)
end

-- attempt to replace cards
function onObjectSpawn(obj)
  if obj.type ~= "Card" then return end

  local md = JSON.decode(obj.getGMNotes()) or {}
  if not md.id then return end

  -- check if it's in the index
  local cardData = getCardById({ id = md.id })
  if cardData == nil then return end

  log("Replaced " .. obj.getName())

  local objData            = obj.getData()
  cardData["GUID"]         = objData.data["GUID"]
  cardData["GMNotes"]      = objData.data["GMNotes"]
  cardData["Tags"]         = objData.data["Tags"]
  cardData["LuaScript"]    = objData.data["LuaScript"]
  cardData["XmlUI"]        = objData.data["XmlUI"]
  cardData["SidewaysCard"] = objData.data["SidewaysCard"]
  cardData["Nickname"]     = objData.data["Nickname"]

  Wait.frames(function()
    obj.destruct()
    spawnObjectData({ data = cardData })
  end, 10)
end
