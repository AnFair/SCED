local playAreaApi = require("core/PlayAreaApi")
local tokenArrangerApi = require("accessories/TokenArrangerApi")
local tokenSpawnTrackerApi = require("core/token/TokenSpawnTrackerApi")

local ENCOUNTER_DECK_AREA = {
  upperLeft = { x = 0.9, z = 0.42 },
  lowerRight = { x = 0.86, z = 0.38 },
}
local ENCOUNTER_DISCARD_AREA = {
  upperLeft = { x = 1.62, z = 0.42 },
  lowerRight = { x = 1.58, z = 0.38 },
}

local currentScenario
local useFrontData
local tokenData

-- we use this to turn off collision handling until onLoad() is complete
local collisionEnabled = false

function onLoad(saveState)
  if saveState ~= nil then
    local loadedState = JSON.decode(saveState) or {}
    currentScenario   = loadedState.currentScenario or ""
    useFrontData      = loadedState.useFrontData or true
    tokenData         = loadedState.tokenData or {}
  end
  collisionEnabled = true
end

function onSave()
  return JSON.encode({
    currentScenario = currentScenario,
    useFrontData    = useFrontData,
    tokenData       = tokenData
  })
end

-- TTS event handler.  Handles scenario name event triggering and encounter card token resets.
function onCollisionEnter(collisionInfo)
  if not collisionEnabled then
    return
  end
  local object = collisionInfo.collision_object
  if object.getName() == "Scenario" then
    local updateNeeded = false
    local description = object.getDescription()

    -- detect if orientation of scenario card changed (flipped to other side)
    if object.is_face_down == useFrontData then
      useFrontData = not useFrontData
      updateNeeded = true
    end

    -- detect if another scenario card is placed down
    if currentScenario ~= description then
      currentScenario = description
      updateNeeded = true
      fireScenarioChangedEvent()
    end

    -- trigger update if a change was detected and push new data
    if updateNeeded then
      local metadata = JSON.decode(object.getGMNotes()) or {}
      if not metadata["tokens"] then
        tokenData = {}
        return
      end
      tokenData = metadata["tokens"][(useFrontData and "front" or "back")]
      fireTokenDataChangedEvent()
    end
  end

  local localPos = self.positionToLocal(object.getPosition())
  if inArea(localPos, ENCOUNTER_DECK_AREA) or inArea(localPos, ENCOUNTER_DISCARD_AREA) then
    tokenSpawnTrackerApi.resetTokensSpawned(object.getGUID())
  end
end

-- TTS event handler. Handles scenario name event triggering
function onCollisionExit(collisionInfo)
  if not collisionEnabled then return end
  local object = collisionInfo.collision_object

  -- reset data if scenario reference card is removed
  if object.getName() == "Scenario" then
    tokenData = {}
    currentScenario = nil
    useFrontData = nil
    fireTokenDataChangedEvent()
  end
end

-- Listens for cards entering the encounter deck or encounter discard, and resets the spawn state
-- for the cards when they do.
function onObjectEnterContainer(container, object)
  local localPos = self.positionToLocal(container.getPosition())
  if inArea(localPos, ENCOUNTER_DECK_AREA) or inArea(localPos, ENCOUNTER_DISCARD_AREA) then
    tokenSpawnTrackerApi.resetTokensSpawned(object.getGUID())
  end
end

-- fires if the scenario title changes
function fireScenarioChangedEvent()
  Wait.frames(function() Global.call('titleSplash', currentScenario) end, 20)
  playAreaApi.onScenarioChanged(currentScenario)
end

-- fires if the scenario title or the difficulty changes
function fireTokenDataChangedEvent()
  local fullData = returnTokenData()
  tokenArrangerApi.onTokenDataChanged(fullData)
end

-- returns the chaos token metadata (if provided)
function returnTokenData()
  return {
    tokenData       = tokenData,
    currentScenario = currentScenario,
    useFrontData    = useFrontData
  }
end

-- Simple method to check if the given point is in a specified area.  Local use only,
---@param point Vector.  Point to check, only x and z values are relevant
---@param bounds Table.  Defined area to see if the point is within.  See MAIN_PLAY_AREA for sample
--     bounds definition.
---@return Boolean.  True if the point is in the area defined by bounds
function inArea(point, bounds)
  return (point.x < bounds.upperLeft.x
      and point.x > bounds.lowerRight.x
      and point.z < bounds.upperLeft.z
      and point.z > bounds.lowerRight.z)
end
