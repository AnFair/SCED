-- static values
Y_VISIBLE    = 0.25
Y_INVISIBLE  = -0.5

-- used for Summoned Servitor and Living Ink
VECTOR_COLOR = {
  unselected = { 0.5, 0.5, 0.5, 0.75 },
  selected   = { 0.597, 0.195, 0.796 }
}

-- used for Summoned Servitor
-- these match with ArkhamDB's way of storing the data in the dropdown menu
SLOT_INDICES = { arcane = "1", ally = "0", none = "" }

-- override 'marked boxes' for debugging ('all' or 'none')
DEBUG        = ""

-- save state when going into bags / decks
function onDestroy() self.script_state = onSave() end

function onSave()
  if selfId == "09079-c" then
    inputValues = {}
    for skill, isSelected in pairs(selectedSkills) do
      if isSelected then
        table.insert(inputValues, skill)
      end
    end
  end
  return JSON.encode({ markedBoxes, inputValues })
end

-- Startup procedure
function onLoad(savedData)
  if savedData ~= "" and DEBUG == "" then
    local loadedData = JSON.decode(savedData)
    markedBoxes      = loadedData[1]
    inputValues      = loadedData[2]
  else
    markedBoxes = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
    inputValues = { "", "", "", "", "" }
  end

  selfId = getSelfId()

  makeData()
  createButtonsAndBoxes()
  maybeLoadSkills()
  maybeUpdateSkillDisplay()
  maybeUpdateSlotDisplay()

  self.addContextMenuItem("Reset Inputs", function() updateState({ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }) end)
  self.addContextMenuItem("Scale: normal", function() self.setScale({ 1, 1, 1 }) end)
  self.addContextMenuItem("Scale: double", function() self.setScale({ 2, 1, 2 }) end)
  self.addContextMenuItem("Scale: triple", function() self.setScale({ 3, 1, 3 }) end)
end

function getSelfId()
  local metadata = JSON.decode(self.getGMNotes())
  return metadata.id
end

function updateState(markedBoxesNew)
  if markedBoxesNew then markedBoxes = markedBoxesNew end
  makeData()
  createButtonsAndBoxes()
  maybeUpdateSkillDisplay()
  maybeUpdateSlotDisplay()
end

-- create Data
function makeData()
  Data = { checkbox = {}, textbox = {} }

  -- repeat this for each entry (= line) in existingBoxes
  local totalCount = 0
  for i = 1, #existingBoxes do
    -- repeat this for each checkbox per line
    for j = 1, existingBoxes[i] do
      totalCount                      = totalCount + 1
      Data.checkbox[totalCount]       = {}
      Data.checkbox[totalCount].pos   = {}
      Data.checkbox[totalCount].pos.x = x_1 + j * x_offset
      Data.checkbox[totalCount].pos.z = posZ[i]
      Data.checkbox[totalCount].row   = i

      if (DEBUG == "all") or (markedBoxes[i] >= j and DEBUG ~= "none") then
        Data.checkbox[totalCount].pos.y = Y_VISIBLE
        Data.checkbox[totalCount].state = true
      else
        Data.checkbox[totalCount].pos.y = Y_INVISIBLE
        Data.checkbox[totalCount].state = false
      end
    end
  end

  -- repeat this for each entry (= line) in inputBoxes
  local totalCount = 0
  for i = 1, #inputBoxes do
    -- repeat this for each textbox per line
    for j = 1, inputBoxes[i] do
      totalCount                     = totalCount + 1
      Data.textbox[totalCount]       = {}
      Data.textbox[totalCount].pos   = inputPos[totalCount]
      Data.textbox[totalCount].width = inputWidth[totalCount]
      Data.textbox[totalCount].value = inputValues[totalCount]
    end
  end
end

-- checks or unchecks the given box
function click_checkbox(tableIndex)
  local row = Data.checkbox[tableIndex].row

  if Data.checkbox[tableIndex].state then
    Data.checkbox[tableIndex].pos.y = Y_INVISIBLE
    Data.checkbox[tableIndex].state = false
    markedBoxes[row] = markedBoxes[row] - 1
  else
    Data.checkbox[tableIndex].pos.y = Y_VISIBLE
    Data.checkbox[tableIndex].state = true
    markedBoxes[row] = markedBoxes[row] + 1
  end

  self.editButton({
    index = tableIndex - 1,
    position = Data.checkbox[tableIndex].pos
  })
end

-- updates saved value for given text box
function click_textbox(i, value, selected)
  if selected == false then
    inputValues[i] = value
  end
end

function createButtonsAndBoxes()
  self.clearButtons()
  self.clearInputs()

  for i, box_data in ipairs(Data.checkbox) do
    local funcName = "checkbox" .. i
    local func = function() click_checkbox(i) end
    self.setVar(funcName, func)

    self.createButton({
      click_function = funcName,
      function_owner = self,
      position       = box_data.pos,
      height         = boxSize * 10,
      width          = boxSize * 10,
      font_size      = 1000,
      scale          = { 0.1, 0.1, 0.1 },
      color          = { 0, 0, 0 },
      font_color     = { 0, 0, 0 }
    })
  end

  for i, box_data in ipairs(Data.textbox) do
    local funcName = "textbox" .. i
    local func = function(_, _, val, sel) click_textbox(i, val, sel) end
    self.setVar(funcName, func)

    self.createInput({
      input_function = funcName,
      function_owner = self,
      label          = "Click to type",
      alignment      = 2,
      position       = box_data.pos,
      scale          = { 0.1, 0.1, 0.1 },
      width          = box_data.width * 10,
      height         = inputFontsize * 10 + 50,
      font_size      = inputFontsize * 10,
      color          = "White",
      font_color     = buttonFontColor,
      value          = box_data.value
    })
  end

  maybeMakeSkillSelectionButtons()
  maybeMakeSlotSelectionButtons()
end

---------------------------------------------------------
-- Living Ink related functions
---------------------------------------------------------

function maybeLoadSkills()
  if selfId ~= "09079-c" then return end
  selectedSkills       = {
    willpower = false,
    intellect = false,
    combat    = false,
    agility   = false
  }
  for _, skill in ipairs(inputValues) do
    if skill ~= "" then
      selectedSkills[skill] = true
    end
  end
end

function click_willpower()
  selectedSkills.willpower = not selectedSkills.willpower
  maybeUpdateSkillDisplay()
end

function click_intellect()
  selectedSkills.intellect = not selectedSkills.intellect
  maybeUpdateSkillDisplay()
end

function click_combat()
  selectedSkills.combat = not selectedSkills.combat
  maybeUpdateSkillDisplay()
end

function click_agility()
  selectedSkills.agility = not selectedSkills.agility
  maybeUpdateSkillDisplay()
end

-- Creates the invisible buttons overlaying the skill icons
function maybeMakeSkillSelectionButtons()
  if selfId ~= "09079-c" then return end

  local buttonData = {
    click_function = "click_willpower",
    function_owner = self,
    position       = { x = -1 * SKILL_ICON_POSITIONS.willpower.x, y = 0.2, z = SKILL_ICON_POSITIONS.willpower.z },
    height         = 130,
    width          = 130,
    scale          = { 1, 1, 1 },
    color          = { 0, 0, 0, 0 },
  }
  self.createButton(buttonData)

  buttonData.click_function = "click_intellect"
  buttonData.position.x = -1 * SKILL_ICON_POSITIONS.intellect.x
  self.createButton(buttonData)

  buttonData.click_function = "click_combat"
  buttonData.position.x = -1 * SKILL_ICON_POSITIONS.combat.x
  self.createButton(buttonData)

  buttonData.click_function = "click_agility"
  buttonData.position.x = -1 * SKILL_ICON_POSITIONS.agility.x
  self.createButton(buttonData)
end

-- Refresh the vector circles indicating a skill is selected.  Since we can only have one table of
-- vectors set, have to refresh all 4 at once
function maybeUpdateSkillDisplay()
  if selfId ~= "09079-c" then return end
  local circles = {}
  for skill, isSelected in pairs(selectedSkills) do
    if isSelected then
      local circle = getCircleVector(SKILL_ICON_POSITIONS[skill])
      if circle ~= nil then
        table.insert(circles, circle)
      end
    end
  end
  self.setVectorLines(circles)
end

function getCircleVector(center)
  local diameter = Vector(0, 0, 0.1)
  local pointOfOrigin = Vector(center.x, 0.3, center.z)

  -- Declare Results vectors
  local vec = Vector(0, 0, 0)
  local vecList = {}
  local arcStep = 5
  for i = 0, 360, arcStep do
    diameter:rotateOver('y', arcStep)
    vec = pointOfOrigin + diameter
    vec.y = pointOfOrigin.y
    table.insert(vecList, vec)
  end

  return {
    points    = vecList,
    color     = VECTOR_COLOR.selected,
    thickness = 0.02,
  }
end

---------------------------------------------------------
-- Summoned Servitor related functions
---------------------------------------------------------

-- Creates the invisible buttons overlaying the slot words
function maybeMakeSlotSelectionButtons()
  if selfId ~= "09080-c" then return end

  local buttonData = {
    click_function = "click_arcane",
    function_owner = self,
    position       = { x = -1 * SLOT_ICON_POSITIONS.arcane.x, y = 0.2, z = SLOT_ICON_POSITIONS.arcane.z },
    height         = 130,
    width          = 130,
    color          = { 0, 0, 0, 0 },
  }
  self.createButton(buttonData)

  buttonData.click_function = "click_ally"
  buttonData.position.x = -1 * SLOT_ICON_POSITIONS.ally.x
  self.createButton(buttonData)
end

function click_arcane()
  if inputValues[1] == SLOT_INDICES.arcane then
    inputValues[1] = SLOT_INDICES.none
  else
    inputValues[1] = SLOT_INDICES.arcane
  end
  maybeUpdateSlotDisplay()
end

function click_ally()
  if inputValues[1] == SLOT_INDICES.ally then
    inputValues[1] = SLOT_INDICES.none
  else
    inputValues[1] = SLOT_INDICES.ally
  end
  maybeUpdateSlotDisplay()
end

-- Refresh the vector circles indicating a slot is selected.
function maybeUpdateSlotDisplay()
  if selfId ~= "09080-c" then return end

  local center

  center               = SLOT_ICON_POSITIONS["arcane"]
  local arcaneVecList  = {
    Vector(center.x + 0.12, 0.3, center.z + 0.05),
    Vector(center.x - 0.12, 0.3, center.z + 0.05),
    Vector(center.x - 0.12, 0.3, center.z - 0.05),
    Vector(center.x + 0.12, 0.3, center.z - 0.05),
    Vector(center.x + 0.12, 0.3, center.z + 0.05),
  }

  center               = SLOT_ICON_POSITIONS["ally"]
  local allyVecList    = {
    Vector(center.x + 0.07, 0.3, center.z + 0.05),
    Vector(center.x - 0.07, 0.3, center.z + 0.05),
    Vector(center.x - 0.07, 0.3, center.z - 0.05),
    Vector(center.x + 0.07, 0.3, center.z - 0.05),
    Vector(center.x + 0.07, 0.3, center.z + 0.05),
  }

  local arcaneVecColor = VECTOR_COLOR.unselected
  local allyVecColor   = VECTOR_COLOR.unselected

  if inputValues[1] == SLOT_INDICES.arcane then
    arcaneVecColor = VECTOR_COLOR.selected
  elseif inputValues[1] == SLOT_INDICES.ally then
    allyVecColor = VECTOR_COLOR.selected
  end

  self.setVectorLines({
    {
      points    = arcaneVecList,
      color     = arcaneVecColor,
      thickness = 0.02,
    },
    {
      points    = allyVecList,
      color     = allyVecColor,
      thickness = 0.02,
    }
  })
end
