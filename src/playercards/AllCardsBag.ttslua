local guidReferenceApi       = require("core/GUIDReferenceApi")

-- card index and sub-indices
local cardIdIndex            = {}
local classAndLevelIndex     = {}
local customInvestigatorData = {}
local basicWeaknessList      = {}
local uniqueWeaknessList     = {}
local cycleIndex             = {}

local indexingDone           = false
local otherCardsDetected     = false

-- helper data for class sorting
local classValueList         = {
  Guardian = 1,
  Seeker   = 2,
  Rogue    = 3,
  Mystic   = 4,
  Survivor = 5,
  Neutral  = 99998,
  Mythos   = 99999
}
local classesInOrder         = {
  "Guardian",
  "Seeker",
  "Rogue",
  "Mystic",
  "Survivor",
  "Neutral"
}

-- conversion tables to simplify type sorting
local typeConversion         = {
  Investigator = 1,
  Minicard     = 2,
  Asset        = 3,
  Event        = 4,
  Skill        = 5,
  Enemy        = 6,
  Treachery    = 7,
  Location     = 8
}

function onLoad()
  self.addContextMenuItem("Rebuild Index", startIndexBuild)
  math.randomseed(os.time())
  Wait.frames(startIndexBuild, 30)
end

-- Called by Hotfix bags when they load. If we are still loading indexes, then
-- the all cards and hotfix bags are being loaded together, and we can ignore
-- this call as the hotfix will be included in the initial indexing. If it is
-- called once indexing is complete it means the hotfix bag has been added
-- later, and we should rebuild the index to integrate the hotfix bag.
function rebuildIndexForHotfix()
  if indexingDone then
    startIndexBuild()
  end
end

-- Resets all current bag indexes
function clearIndexes()
  indexingDone           = false
  cardIdIndex            = {}
  classAndLevelIndex     = {}
  cycleIndex             = {}
  customInvestigatorData = {}
  basicWeaknessList      = {}
  uniqueWeaknessList     = {}
end

-- Clears the bag indexes and starts the coroutine to rebuild the indexes
function startIndexBuild()
  clearIndexes()
  startLuaCoroutine(self, "buildIndex")
end

function onObjectLeaveContainer(container, _)
  if container == self then
    broadcastToAll("Removing cards from the All Player Cards bag may break some functions.", "Red")
  end
end

-- Create the card indexes by iterating all cards in the bag, parsing their metadata
-- and creating the keyed lookup tables for the cards. This is a coroutine which will
-- spread the workload by processing 20 cards before yielding.
function buildIndex()
  cardCount = 0
  indexingDone = false
  otherCardsDetected = false

  -- process the allcardsbag itself
  local selfData = self.getData()
  if selfData.ContainedObjects then
    processContainedObjects(selfData.ContainedObjects)
  end

  -- process hotfix bags (and the additional playercards bag)
  for _, hotfixBag in ipairs(getObjectsWithTag("AllCardsHotfix")) do
    local hotfixData = hotfixBag.getData()
    if hotfixData.ContainedObjects then
      processContainedObjects(hotfixData.ContainedObjects, hotfixData.CustomDeck)
    end
  end

  buildSupplementalIndexes()
  updatePlayerCardPanel()
  indexingDone = true
  return 1
end

-- Processes the contained objects for cards to add to the index
function processContainedObjects(containedObjects, customDeck)
  for _, objData in ipairs(containedObjects) do
    if objData.ContainedObjects then
      -- recursively process nested containers
      processContainedObjects(objData.ContainedObjects, objData.CustomDeck)
    else
      -- we might need to fix the "CustomDeck" entry for cards inside decks since TTS doesn't update it while they are in bags
      if customDeck then
        local wantedCustomDeckIdStr = tostring(objData.CardID):sub(1, -3)
        local presentCustomDeckIdNum = next(objData.CustomDeck)

        -- type conversion (TTS seems to store these as strings, but reads them as numbers)
        local wantedCustomDeckIdNum = tonumber(wantedCustomDeckIdStr)

        if wantedCustomDeckIdNum ~= presentCustomDeckIdNum then
          if customDeck[wantedCustomDeckIdNum] then
            objData.CustomDeck = {}
            objData.CustomDeck[wantedCustomDeckIdStr] = customDeck[wantedCustomDeckIdNum]
            log("Correct CustomDeckData for " .. objData.Nickname)
          else
            log("Could not correct CustomDeckData for " .. objData.Nickname)
            return
          end
        end
      end

      addCardToIndex(objData)
      cardCount = cardCount + 1
      if cardCount > 19 then
        cardCount = 0
        coroutine.yield(0)
      end
    end
  end
end

-- Adds a card to any indexes it should be a part of, based on its metadata
---@param cardData table TTS object data for the card
function addCardToIndex(cardData)
  -- using the more efficient 'json.parse()' to speed this process up
  local status, cardMetadata = pcall(function() return json.parse(cardData.GMNotes) end)

  -- if an error happens, fallback to the regular parser
  if status ~= true or cardMetadata == nil then
    log("Fast parser failed for " .. cardData.Nickname .. ", using old parser instead.")
    cardMetadata = JSON.decode(cardData.GMNotes)
  end

  -- if metadata was not valid JSON or empty, don't add the card
  if not cardMetadata then
    log("Error parsing " .. cardData.Nickname)
    return
  end

  -- use the ZoopGuid as fallback if no id present
  cardMetadata.id = cardMetadata.id or cardMetadata.TtsZoopGuid
  local indexData = { data = cardData, metadata = cardMetadata }
  cardIdIndex[cardMetadata.id] = indexData

  -- also add data for alternate ids
  if cardMetadata.alternate_ids then
    for _, alternateId in ipairs(cardMetadata.alternate_ids) do
      cardIdIndex[alternateId] = indexData
    end
  end
end

-- Creates the supplemental indexes for classes, weaknesses etc.
function buildSupplementalIndexes()
  for cardId, card in pairs(cardIdIndex) do
    -- If the ID key and the metadata ID don't match this is a duplicate card created by an alternate_id, and we should skip it
    if cardId == card.metadata.id then
      -- Add card to the basic weakness list, if appropriate. Some weaknesses have multiple copies, and are added multiple times
      if card.metadata.weakness then
        table.insert(uniqueWeaknessList, cardId)
        if card.metadata.basicWeaknessCount ~= nil then
          for i = 1, card.metadata.basicWeaknessCount do
            table.insert(basicWeaknessList, cardId)
          end
        end
      end

      -- Excludes signature cards and story assets for official cycles (which have no class or level)
      if card.metadata.class and card.metadata.level then
        local upgradeKey = "-level0"
        if card.metadata.level > 0 then
          upgradeKey = "-upgrade"
        end

        -- parse classes (separated by "|") and add the card to the appropriate class and level indices
        for str in card.metadata.class:gmatch("([^|]+)") do
          writeToNestedTable(classAndLevelIndex, str .. upgradeKey, cardId)
        end
      end

      -- add to cycle index
      local cycleName = card.metadata.cycle

      -- if this is a minicard without cycle, check the parent card for cycle data
      if not cycleName and card.metadata.type == "Minicard" then
        local parentId = getParentId(cardId)
        local parent = cardIdIndex[parentId]
        if parent and parent.metadata.cycle then
          cycleName = parent.metadata.cycle
        end
      end

      if cycleName then
        cycleName = string.lower(cycleName)

        -- remove "return to " from cycle names
        cycleName = cycleName:gsub("return to ", "")

        -- override cycle name for night of the zealot
        cycleName = cycleName:gsub("the night of the zealot", "core")
      else
        -- track cards without defined cycle (should only be fan-made cards)
        cycleName = "other"
        otherCardsDetected = true

        -- maybe add to special investigator / minicard index
        if card.metadata.type == "Investigator" then
          writeToNestedTable(customInvestigatorData, "InvestigatorGroup", cardId)
          writeToNestedTable(customInvestigatorData, "InvestigatorSubdata", cardId, "cards", cardId)
        elseif card.metadata.type == "Minicard" then
          local parentId = getParentId(cardId)
          writeToNestedTable(customInvestigatorData, "InvestigatorSubdata", parentId, "minicards", cardId)
        end
      end

      -- maybe initialize table
      writeToNestedTable(cycleIndex, cycleName, cardId)
    end
  end

  -- sort class and level indices
  for _, indexTable in pairs(classAndLevelIndex) do
    table.sort(indexTable, cardComparator)
  end

  -- sort cycle indices
  for _, indexTable in pairs(cycleIndex) do
    table.sort(indexTable)
  end

  -- sort weakness indices
  table.sort(basicWeaknessList, cardComparator)
  table.sort(uniqueWeaknessList, cardComparator)

  -- sort custom investigator / minicard data
  for _, indexTable in pairs(customInvestigatorData) do
    table.sort(indexTable, metadataSortFunction)
  end
end

-- get the parent id for minicards by removing the last two characters
function getParentId(miniId)
  return string.sub(miniId, 1, -3)
end

-- helper function to ensure nested tables are initialized - last argument will be used as table element
function writeToNestedTable(rootTable, ...)
  local args = { ... }
  local currentTable = rootTable

  for i = 1, #args - 1 do
    local key = args[i]
    if not currentTable[key] then
      currentTable[key] = {}
    end
    currentTable = currentTable[key]
  end
  table.insert(currentTable, args[#args])
end

-- Comparison function used to sort the class card bag indexes. Sorts by card level, then name, then subname.
function cardComparator(id1, id2)
  local card1 = cardIdIndex[id1]
  local card2 = cardIdIndex[id2]

  -- get level per card (use 6 to sort cards last without level)
  local level1 = card1.metadata.level or 6
  local level2 = card2.metadata.level or 6

  if level1 ~= level2 then
    return level1 < level2
  elseif card1.data.Nickname ~= card2.data.Nickname then
    return card1.data.Nickname < card2.data.Nickname
  else
    return card1.data.Description < card2.data.Description
  end
end

-- inform the player card panel about the presence of other cards (no cycle -> fan-made)
function updatePlayerCardPanel()
  local panel = guidReferenceApi.getObjectByOwnerAndType("Mythos", "PlayerCardPanel")
  panel.call("createXML", otherCardsDetected)
end

---@return boolean: If true, the bag is currently not indexing and ready to be accessed
function isIndexReady()
  if not indexingDone then
    broadcastToAll("Still loading player cards, please try again in a few seconds", { 0.9, 0.2, 0.2 })
  end
  return indexingDone
end

-- Returns a specific card from the bag, based on ArkhamDB ID
---@param params table ID of the card to retrieve
---@return table: If the indexes are still being constructed, returns an empty table.
--  Otherwise, a single table with the following fields
--    data: TTS object data, suitable for spawning the card
--    metadata: Table of parsed metadata
function getCardById(params)
  if not isIndexReady() then return {} end
  return cardIdIndex[params.id]
end

-- Returns a list of cards from the bag matching a class and level (0 or upgraded)
---@param params table
--  class: String class to retrieve ("Guardian", "Seeker", etc)
--  isUpgraded: true for upgraded cards (Level 1-5), false for Level 0
---@return table: If the indexes are still being constructed, returns an empty table.
--  Otherwise, a list of tables, each with the following fields
--    data: TTS object data, suitable for spawning the card
--    metadata: Table of parsed metadata
function getCardsByClassAndLevel(params)
  if not isIndexReady() then return {} end

  local upgradeKey = "-level0"
  if params.upgraded then
    upgradeKey = "-upgrade"
  end
  return classAndLevelIndex[params.class .. upgradeKey]
end

-- Returns a list of cards from the bag matching a cycle
---@param params table
--  cycle: string Name of the cycle to retrieve ("The Scarlet Keys" etc.)
--  sortByMetadata: boolean If true, sorts the table by metadata instead of ID
--  includeNoLevelCards: boolean If true, includes cards without level
---@return table: If the indexes are still being constructed, returns an empty table.
--  Otherwise, a list of tables, each with the following fields
--    data: TTS object data, suitable for spawning the card
--    metadata: Table of parsed metadata
function getCardsByCycle(params)
  if not isIndexReady() then return {} end

  local cycleData = cycleIndex[string.lower(params.cycle)] or {}

  -- create a copy of the data to not change the source
  local cardList = {}
  for _, id in ipairs(cycleData) do
    local md = cardIdIndex[id].metadata
    -- only include cards without level if requested (don't include investigators / minicards though)
    if (md.level or params.includeNoLevelCards) and md.type ~= "Investigator" and md.type ~= "Minicard" then
      table.insert(cardList, id)
    end
  end

  -- sort list by metadata (useful for custom cards without proper IDs)
  if params.sortByMetadata and #cardList > 0 then
    table.sort(cardList, metadataSortFunction)
  end
  return cardList
end

-- sorts cards by metadata: class, type, level, name and then description
function metadataSortFunction(id1, id2)
  local card1 = cardIdIndex[id1]
  local card2 = cardIdIndex[id2]

  -- extract class per card
  local classValue1 = getClassValue(card1.metadata.class)
  local classValue2 = getClassValue(card2.metadata.class)

  -- get value to sort by type per card
  local type1 = typeConversion[card1.metadata.type] or 99
  local type2 = typeConversion[card2.metadata.type] or 99

  -- get level per card (use 6 to sort cards last without level)
  local level1 = card1.metadata.level or 6
  local level2 = card2.metadata.level or 6

  -- actual sorting
  if classValue1 ~= classValue2 then
    return classValue1 < classValue2
  elseif type1 ~= type2 then
    return type1 < type2
  elseif level1 ~= level2 then
    return level1 < level2
  elseif card1.data.Nickname ~= card2.data.Nickname then
    return card1.data.Nickname < card2.data.Nickname
  else
    return card1.data.Description < card2.data.Description
  end
end

-- helper function to calculate the class value for sorting from the "|" separated string
function getClassValue(s)
  -- make sure cards without class (e.g. weaknesses) get sorted last
  if not s then return 99999 end

  -- split the "|" separated string and remove whitespace
  local splitClasses = {}
  for str in s:gmatch("([^|]+)") do
    str = str:gsub("%s", "")
    splitClasses[str] = true
  end

  -- sort multiclass cards (outputs 12 for "Guardian|Seeker")
  local classValue = 0
  local multiplier = 1
  for _, class in pairs(classesInOrder) do
    if splitClasses[class] then
      classValue = classValue + classValueList[class] * multiplier
      multiplier = multiplier * 10
    end
  end

  return classValue
end

function getCustomInvestigatorData()
  if not isIndexReady() then return {} end

  return {
    InvestigatorGroup = customInvestigatorData.InvestigatorGroup or {},
    InvestigatorSubdata = customInvestigatorData.InvestigatorSubdata or {}
  }
end

-- Searches the bag for cards which match the given name and returns a list. Note that this is
-- an O(n) search without index support. It may be slow.
-- Parameter array must contain these fields to define the search:
--   name: String or string fragment to search for names
--   exact: Whether the name match should be exact
function getCardsByName(params)
  local name = params.name
  local exact = params.exact
  local results = {}

  -- Track cards (by ID) that we've added to avoid duplicates that may come from alternate IDs
  local addedCards = {}
  for _, cardData in pairs(cardIdIndex) do
    if (not addedCards[cardData.metadata.id]) then
      if (exact and (string.lower(cardData.data.Nickname) == string.lower(name)))
          or (not exact and string.find(string.lower(cardData.data.Nickname), string.lower(name), 1, true)) then
        table.insert(results, cardData)
        addedCards[cardData.metadata.id] = true
      end
    end
  end
  return results
end

-- Gets a random basic weakness from the bag. Once a given ID has been returned it will be
-- removed from the list and cannot be selected again until a reload occurs or the indexes
-- are rebuilt, which will refresh the list to include all weaknesses.
---@param params table Bundled parameters:
---  count number Number of weaknesses
---  restrictions table Additional restrictions:
---    class string Class to restrict weakness to
---    standalone boolean Whether 'Campaign only' weaknesses should be exluded
---    traits? string Trait(s) to use as filter
---@return table: Table with IDs of the selected weaknesses
function getRandomWeaknessIds(params)
  params.count = params.count or 1
  local availableWeaknesses = buildAvailableWeaknesses(params.restrictions)

  -- check if enough weaknesses are available
  local missingWeaknesses = params.count - #availableWeaknesses
  if missingWeaknesses > 0 then
    broadcastToAll("Not enough basic weaknesses available! (" .. missingWeaknesses .. " missing)", { 0.9, 0.2, 0.2 })
  end

  local drawnWeaknesses = {}

  -- Fisher-Yates shuffle algorithm
  local n = #availableWeaknesses
  for i = 1, math.min(params.count, n) do
    local index = math.random(i, n)
    table.insert(drawnWeaknesses, availableWeaknesses[index])
    availableWeaknesses[index], availableWeaknesses[i] = availableWeaknesses[i], availableWeaknesses[index]
  end

  return drawnWeaknesses
end

-- Constructs a list of available basic weaknesses by starting with the full pool of basic
-- weaknesses then removing any which are currently in the play or deck construction areas
---@param restrictions? table Additional restrictions:
---  class string Class to restrict weakness to
---  standalone boolean Whether 'Campaign only' weaknesses should be exluded
---  traits? string Trait(s) to use as filter
---@return table: Array of weakness IDs which are valid to choose from
function buildAvailableWeaknesses(restrictions)
  restrictions = restrictions or {}
  local weaknessesInPlay = {}
  local allObjects = getAllObjects()
  for _, object in ipairs(allObjects) do
    if object.type == "Deck" then
      for _, cardData in ipairs(object.getData().ContainedObjects) do
        incrementWeaknessCount(weaknessesInPlay, JSON.decode(cardData.GMNotes))
      end
    elseif object.type == "Card" then
      incrementWeaknessCount(weaknessesInPlay, JSON.decode(object.getGMNotes()))
    end
  end

  local availableWeaknesses = {}
  for _, weaknessId in ipairs(basicWeaknessList) do
    if (weaknessesInPlay[weaknessId] ~= nil and weaknessesInPlay[weaknessId] > 0) then
      weaknessesInPlay[weaknessId] = weaknessesInPlay[weaknessId] - 1
    else
      local eligible = true

      -- disable 'Campaign only' weaknesses in standalone mode
      if restrictions.standalone then
        local card = cardIdIndex[weaknessId]
        if card.metadata.modeRestriction == "Campaign" then
          eligible = false
        end
      end

      -- disable class restricted weaknesses
      if restrictions.class then
        local card = cardIdIndex[weaknessId]
        if card.metadata.classRestriction and card.metadata.classRestriction ~= restrictions.class then
          eligible = false
        end
      end

      -- disable non-matching traits
      if restrictions.traits then
        -- split the string into separate traits (separated by "|")
        local allowedTraits = {}
        for str in restrictions.traits:gmatch("([^|]+)") do
          -- remove dots
          str = str:gsub("[%.]", "")

          -- remove leading and trailing whitespace
          str = str:match("^%s*(.-)%s*$")

          -- make sure string ends with a dot
          str = string.lower(str .. ".")
          table.insert(allowedTraits, str)
        end

        local match = false

        -- make sure the trait is present on the weakness
        local card = cardIdIndex[weaknessId]
        for _, allowedTrait in ipairs(allowedTraits) do
          if string.contains(string.lower(card.metadata.traits), allowedTrait) then
            match = true
            break
          end
        end

        if not match then
          eligible = false
        end
      end

      -- add weakness to list if eligible
      if eligible then
        table.insert(availableWeaknesses, weaknessId)
      end
    end
  end
  return availableWeaknesses
end

function getBasicWeaknesses()
  return basicWeaknessList
end

function getUniqueWeaknesses()
  return uniqueWeaknessList
end

-- Helper function that adds one to the table entry for the number of weaknesses in play
function incrementWeaknessCount(table, cardMetadata)
  if isBasicWeakness(cardMetadata) then
    if table[cardMetadata.id] == nil then
      table[cardMetadata.id] = 1
    else
      table[cardMetadata.id] = table[cardMetadata.id] + 1
    end
  end
end

function isBasicWeakness(cardMetadata)
  return cardMetadata ~= nil
      and cardMetadata.weakness
      and cardMetadata.basicWeaknessCount ~= nil
      and cardMetadata.basicWeaknessCount > 0
end
