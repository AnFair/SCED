require("core/Constants")
local searchLib = require("util/SearchLib")

local idList = {}

local galleryTemplateStart = [[<style>
  .sced-image {
    max-width: 49%;
    height: auto;
    border-radius: 8px;
    box-shadow: 0px 5px 10px rgba(0, 0, 0, 0.4);
    margin: 0;
    transition: transform 0.3s ease-in-out;
  }
  .sced-image:hover { transform: scale(1.45); }
  .sced-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 5px;
    margin-top: 5px;
    padding: 10px;
  }
  .sced-spacer { height: 50px; }
  @media (max-width: 600px) {
    .sced-image { max-width: 100%; }
    .sced-image:hover { transform: none; }
    .sced-spacer { height: 0px; }
  }
</style>
<div class="sced-container">\n]]
local galleryTemplateMiddle = [[  <img class="sced-image" src="{{IMAGE_URL}}"/>\n]]
local galleryTemplateEnd = [[</div>\n<div class="sced-spacer"></div>]]

function onLoad()
  -- "generate" button
  local buttonParameters          = {}
  buttonParameters.function_owner = self
  buttonParameters.height         = 200
  buttonParameters.width          = 800
  buttonParameters.click_function = "generate"
  buttonParameters.color          = { 0, 0, 0, 0 }
  buttonParameters.position       = { 0, 0.11, 0.74 }
  buttonParameters.scale          = { 0.5, 1, 0.5 }
  self.createButton(buttonParameters)
end

-- generates a string for the deck notes that will instruct the Deck Importer to add the specified cards
function generate(_, playerColor)
  idList = {}
  for _, obj in ipairs(searchLib.onObject(self, "isCardOrDeck")) do
    if obj.type == "Card" then
      processCard(obj.getData(), playerColor)
    elseif obj.type == "Deck" then
      for _, deepObjData in ipairs(obj.getData().ContainedObjects) do
        processCard(deepObjData, playerColor)
      end
    end
  end

  if #idList == 0 then
    broadcastToColor("Didn't find any valid cards.", playerColor, "Red")
    return
  else
    local cardString = #idList .. " cards"
    if #idList == 1 then
      cardString = " 1 card"
    end
    broadcastToColor("Parsed " .. cardString .. ": Go to Notebook > Deck Instructions", playerColor, "Green")
  end

  -- sort the idList
  table.sort(idList, sortById)

  -- construct the string (new line for each instruction)
  local descriptionParts = {}
  table.insert(descriptionParts, "++SCED import instructions++")

  -- create the main part of the instructions
  local createGallery = false
  for _, entry in ipairs(idList) do
    -- start a new line and add first part of instruction
    table.insert(descriptionParts, "\n- add: " .. entry.id .. " (")

    -- maybe add hyperlink to card face
    if entry.face then
      createGallery = true
      table.insert(descriptionParts, '<a href="' .. entry.face .. '">')
    end

    -- name of the card
    table.insert(descriptionParts, "**" .. entry.name .. "**")

    -- maybe close hyperlink
    if entry.face then
      table.insert(descriptionParts, "</a>")
    end

    -- closing bracket
    table.insert(descriptionParts, ")")

    -- maybe add hyperlink for back
    if entry.back then
      createGallery = true
      table.insert(descriptionParts, ' (<a href="' .. entry.back .. '">Back</a>)')
    end
  end

  -- maybe create a card gallery for included cards
  if createGallery then
    table.insert(descriptionParts, "\n\n")
    table.insert(descriptionParts, galleryTemplateStart)

    -- add cards
    for _, entry in ipairs(idList) do
      if entry.face then
        table.insert(descriptionParts, galleryTemplateMiddle:gsub("{{IMAGE_URL}}", entry.face))
      end
      if entry.back then
        table.insert(descriptionParts, galleryTemplateMiddle:gsub("{{IMAGE_URL}}", entry.back))
      end
    end
    table.insert(descriptionParts, galleryTemplateEnd)
  end

  local description = table.concat(descriptionParts, "")

  -- get a timestamp
  local timestamp = os.date("%Y-%m-%d %H:%M")

  -- get notebook data
  for _, nb in ipairs(Notes.getNotebookTabs()) do
    if nb.title == "Deck Instructions" then
      -- edit the existing tab
      Notes.editNotebookTab({
        index = nb.index,
        body = nb.body .. "\n\n" .. timestamp .. "\n" .. description,
      })
      return
    end
  end

  -- add a new notebook tab for it (since there was no existing tab)
  Notes.addNotebookTab({
    title = "Deck Instructions",
    body =
        "Make sure to copy the section beginning with '++SCED import instructions++' to your ArkhamDB / arkham.build deck description." ..
        "\nAfter doing so, the Deck Importer will be able to spawn these cards IF they are added to the mod's card index (for example by " ..
        "throwing them into the 'Additional Cards Box' next to the Player Cards Panel in the upper left corner of the table." ..
        "\nIt also supports '- remove:' instructions to automatically remove placeholder cards.\nIf you are using a custom " ..
        "investigator, make sure to use a 'remove' instruction to remove the original one.\n" .. timestamp .. "\n" .. description
  })
end

-- use the ZoopGuid as fallback if no id present
function getIdFromData(metadata)
  if metadata.id then
    return metadata.id
  elseif metadata.TtsZoopGuid then
    return metadata.TtsZoopGuid
  end
end

function processCard(cardData, playerColor)
  local id = getIdFromData(JSON.decode(cardData.GMNotes) or {})
  if id then
    local cardDetails = { id = id, name = cardData.Nickname }

    -- if this is not a decksheet, add its URL
    local _, customDeckData = next(cardData["CustomDeck"])
    if customDeckData["NumHeight"] == 1 and customDeckData["NumWidth"] == 1 then
      cardDetails.face = customDeckData["FaceURL"]

      -- also add the back if it's not one of the regular backs
      if customDeckData["BackURL"] ~= CARD_BACK_URL.PlayerCard and customDeckData["BackURL"] ~= CARD_BACK_URL.PlayerCard then
        cardDetails.back = customDeckData["BackURL"]
      end
    end

    table.insert(idList, cardDetails)
  else
    broadcastToColor("Couldn't get ID for " .. cardData.Nickname .. ".", playerColor, "Red")
  end
end

function sortById(a, b)
  local numA = tonumber(a.id)
  local numB = tonumber(b.id)

  if numA and numB then
    return numA < numB
  else
    return a.name < b.name
  end
end
