require("core/Constants")
local searchLib = require("util/SearchLib")

local idList = {}

local cardWidth = 250
local cardHeight = cardWidth * 1.4
local galleryTemplateStart = [[<style>
  .sced-spacer { height: 60px; }
  .sced-card { width: 250px; border-radius: 5px; margin: 0; transition: transform 0.25s ease-in-out; }
  .sced-slice { background-repeat: no-repeat; }
  .sced-card:hover { transform: scale(1.45); }
  .sced-card-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 5px;
    margin-top: 5px;
    padding: 10px;
  }
  @media (max-width: 600px) {
    .sced-spacer { height: 0px; }
    .sced-card { width: 100%; height: auto; }
    .sced-card:hover { transform: none; }
  }
</style>
<div class="sced-container">]]
local templateCardRegular = [[  <img class="sced-card sced-regular" src="{{IMAGE_URL}}"/>]]
local templateCardSlice = [[  <div class="sced-card sced-card-slice" style="background-image: url('{{IMAGE_URL}}'); background-size: {{SHEET_SIZE_1}}px {{SHEET_SIZE_2}}px; background-position: {{OFFSET_1}}px {{OFFSET_2}}px;"></div>]]
local galleryTemplateEnd = [[</div>]] .. "\n" .. [[<div class="sced-spacer"></div>]]

function onLoad()
  local buttonParameters          = {}
  buttonParameters.function_owner = self
  buttonParameters.height         = 200
  buttonParameters.width          = 800
  buttonParameters.click_function = "generate"
  buttonParameters.color          = { 0, 0, 0, 0 }
  buttonParameters.position       = { 0, 0.11, 0.74 }
  buttonParameters.scale          = { 0.5, 1, 0.5 }
  self.createButton(buttonParameters)
end

-- generates a string for the deck notes that will instruct the Deck Importer to add the specified cards
function generate(_, playerColor)
  idList = {}
  for _, obj in ipairs(searchLib.onObject(self, "isCardOrDeck")) do
    if obj.type == "Card" then
      processCard(obj.getData(), playerColor)
    elseif obj.type == "Deck" then
      for _, deepObjData in ipairs(obj.getData().ContainedObjects) do
        processCard(deepObjData, playerColor)
      end
    end
  end

  if #idList == 0 then
    broadcastToColor("Didn't find any valid cards.", playerColor, "Red")
    return
  else
    local cardString = #idList .. " cards"
    if #idList == 1 then
      cardString = " 1 card"
    end
    broadcastToColor("Parsed " .. cardString .. ": Go to Notebook > Deck Instructions", playerColor, "Green")
  end

  -- sort the idList
  table.sort(idList, sortByMetadata)

  -- construct the string (new line for each instruction)
  local descriptionParts = {}
  table.insert(descriptionParts, "++SCED import instructions++")

  -- create the main part of the instructions
  local createGallery = false
  for _, entry in ipairs(idList) do
    -- start a new line and add first part of instruction
    table.insert(descriptionParts, "\n- add: " .. entry.id .. " (")

    -- maybe add hyperlink to card face
    if entry.face then
      createGallery = true
      table.insert(descriptionParts, '<a href="' .. entry.face .. '">')
    end

    -- name of the card
    table.insert(descriptionParts, "**" .. entry.name .. "**")

    -- maybe close hyperlink
    if entry.face then
      table.insert(descriptionParts, "</a>")
    end

    -- closing bracket
    table.insert(descriptionParts, ")")

    -- maybe add hyperlink for back
    if entry.back then
      createGallery = true
      table.insert(descriptionParts, ' (<a href="' .. entry.back .. '">Back</a>)')
    end
  end

  -- maybe create a card gallery for included cards
  if createGallery then
    table.insert(descriptionParts, "\n\n" .. galleryTemplateStart .. "\n")

    addedImages = {}
    for _, entry in ipairs(idList) do
      maybeAddImageToGallery(descriptionParts, entry)
    end
    table.insert(descriptionParts, galleryTemplateEnd)
  end

  local description = table.concat(descriptionParts, "")

  -- get a timestamp
  local timestamp = os.date("%Y-%m-%d %H:%M")

  -- get notebook data
  for _, nb in ipairs(Notes.getNotebookTabs()) do
    if nb.title == "Deck Instructions" then
      -- edit the existing tab
      Notes.editNotebookTab({
        index = nb.index,
        body = nb.body .. "\n\n" .. timestamp .. "\n" .. description,
      })
      return
    end
  end

  -- add a new notebook tab for it (since there was no existing tab)
  Notes.addNotebookTab({
    title = "Deck Instructions",
    body =
        "Make sure to copy the section beginning with '++SCED import instructions++' to your ArkhamDB / arkham.build deck description." ..
        "\nAfter doing so, the Deck Importer will be able to spawn these cards IF they are added to the mod's card index (for example by " ..
        "throwing them into the 'Additional Cards Box' next to the Player Cards Panel in the upper left corner of the table." ..
        "\nIt also supports '- remove:' instructions to automatically remove placeholder cards.\nIf you are using a custom " ..
        "investigator, make sure to use a 'remove' instruction to remove the original one.\n\n" .. timestamp .. "\n" .. description
  })
end

-- use the ZoopGuid as fallback if no id present
function getIdFromData(metadata)
  if metadata.id then
    return metadata.id
  elseif metadata.TtsZoopGuid then
    return metadata.TtsZoopGuid
  end
end

function maybeAddImageToGallery(t, data)
  if data.sheetH and data.sheetW then
    -- add cards from decksheets
    local element = templateCardSlice
    element = element:gsub("{{SHEET_SIZE_1}}", data.sheetW * cardWidth):gsub("{{SHEET_SIZE_2}}", data.sheetH * cardHeight)
    element = element:gsub("{{OFFSET_1}}", data.col * cardWidth):gsub("{{OFFSET_2}}", data.row * cardHeight)

    maybeAddCardSlice(t, element, data.face, data.cardId)

    if data.uniqueBack then
      maybeAddCardSlice(t, element, data.back, data.cardId)
    else
      maybeAddCardRegular(t, data.back)
    end
  else
    -- add regular cards
    maybeAddCardRegular(t, data.face)
    maybeAddCardRegular(t, data.back)
  end
end

function maybeAddCardRegular(t, url)
  if not url then return end

  if not addedImages[url] then
    addedImages[url] = true
    table.insert(t, templateCardRegular:gsub("{{IMAGE_URL}}", url) .. "\n")
  end
end

function maybeAddCardSlice(t, element, url, cardId)
  if not url then return end

  -- initialize table
  addedImages[url] = addedImages[url] or {}

  if not addedImages[url][cardId] then
    addedImages[url][cardId] = true
    table.insert(t, element:gsub("{{IMAGE_URL}}", url) .. "\n")
  end
end

function processCard(cardData, playerColor)
  local md = JSON.decode(cardData.GMNotes) or {}
  local id = getIdFromData(md)
  if id then
    local cardDetails = {
      id = id,
      name = cardData.Nickname,
      metadata = md,
      cardId = math.floor(cardData.CardID % 100)
    }

    -- add images unless minicard
    if md.type ~= "Minicard" then
      local _, customDeckData = next(cardData["CustomDeck"])
      cardDetails.face = customDeckData["FaceURL"]

      if customDeckData["NumHeight"] > 1 or customDeckData["NumWidth"] > 1 then
        cardDetails.sheetH = customDeckData["NumHeight"]
        cardDetails.sheetW = customDeckData["NumWidth"]
        cardDetails.row, cardDetails.col = getGridPosition(cardDetails.cardId, customDeckData["NumWidth"])
      end

      -- also add the back if it's not one of the regular backs
      if customDeckData["BackURL"] ~= CARD_BACK_URL.PlayerCard and customDeckData["BackURL"] ~= CARD_BACK_URL.PlayerCard then
        cardDetails.back = customDeckData["BackURL"]
        cardDetails.uniqueBack = customDeckData["UniqueBack"]
      end
    end

    table.insert(idList, cardDetails)
  else
    broadcastToColor("Couldn't get ID for " .. cardData.Nickname .. ".", playerColor, "Red")
  end
end

function sortByMetadata(a, b)
  local numA = tonumber(a.id)
  local numB = tonumber(b.id)

  local isInvestigatorA = (a.metadata.type == "Investigator")
  local isInvestigatorB = (b.metadata.type == "Investigator")

  if isInvestigatorA and not isInvestigatorB then
    return true
  elseif isInvestigatorB and not isInvestigatorA then
    return false
  elseif numA and numB then
    return numA < numB
  else
    return a.name < b.name
  end
end

function getGridPosition(index, columns)
  local row = math.floor(index / columns) + 1
  local column = (index % columns) + 1
  return row, column
end
